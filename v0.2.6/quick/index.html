<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick Interface · QuickPOMDPs</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>QuickPOMDPs</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">QuickPOMDPs.jl</a></li><li><a class="toctext" href="../discrete_explicit/">Discrete Explicit Interface</a></li><li class="current"><a class="toctext" href>Quick Interface</a><ul class="internal"><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Keyword-arguments-1">Keyword arguments</a></li><li><a class="toctext" href="#IDs-and-defining-methods-1">IDs and defining methods</a></li><li><a class="toctext" href="#State,-action,-and-observation-type-inference-1">State, action, and observation type inference</a></li><li><a class="toctext" href="#Visualization-1">Visualization</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Quick Interface</a></li></ul><a class="edit-page" href="https://github.com/JuliaPOMDP/QuickPOMDPs.jl/blob/master/docs/src/quick.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Quick Interface</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Quick-Interface-1" href="#Quick-Interface-1">Quick Interface</a></h1><p>The Quick Interface is designed for defining simple POMDPs in a few lines without any object oriented programming. It exposes nearly all of the problem definition features of POMDPs.jl through constructor keyword arguments.</p><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>The quick interface is perhaps best demonstrated by an example. The code below defines the classic &quot;Mountain Car&quot; problem from  <a href="https://github.com/openai/gym/blob/master/gym/envs/classic_control/mountain_car.py">OpenAI Gym</a>.</p><pre><code class="language-julia">using QuickPOMDPs

mountaincar = QuickMDP(
    function (s, a, rng)        
        x, v = s
        vp = clamp(v + a*0.001 + cos(3*x)*-0.0025, -0.07, 0.07)
        xp = x + vp
        if xp &gt; 0.5
            r = 100.0
        else
            r = -1.0
        end
        return (sp=(xp, vp), r=r)
    end,
    actions = [-1., 0., 1.],
    initialstate = (-0.5, 0.0),
    discount = 0.95,
    isterminal = s -&gt; s[1] &gt; 0.5
)</code></pre><p>Here, the first argument to the <code>QuickMDP</code> constructor is a function that defines the generative model of the MDP. It returns a <code>NamedTuple</code> containing the next state and reward given the current state and action.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Quick(PO)MDPs need not be generative models. Explicit Quick(PO)MDPs can be defined by leaving out the generative function positional argument and providing the <code>transition</code>, <code>observation</code>, and <code>reward</code> keyword arguments. An example of this style can be found in <a href="https://github.com/JuliaPOMDP/QuickPOMDPs.jl/blob/master/examples/lightdark.jl">examples/lightdark.jl</a>.</p></div></div><p>The other keyword arguments define the remaining elements of the problem such as the action space, discount factor and when to terminate.</p><h2><a class="nav-anchor" id="Keyword-arguments-1" href="#Keyword-arguments-1">Keyword arguments</a></h2><p>The keyword arguments correspond to functions in the <a href="https://juliapomdp.github.io/POMDPs.jl/stable/api/#Index-1">POMDPs.jl interface</a>. More information for each can be found in the <a href="https://juliapomdp.github.io/POMDPs.jl/stable/api/#Model-Functions-1">docstring for the function</a>.</p><p>The currently supported keyword arguments are</p><pre><code class="language-none">transition
observation
initialstate_distribution
reward
initialstate
initialobs
states
actions
observations
discount
stateindex
actionindex
obsindex
isterminal
obs_weight (from POMDPModelTools)
render (from POMDPModelTools)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The <code>gen</code> function (which should always return a <code>NamedTuple</code>) can be defined as a first positional argument (or with the <code>do</code> syntax) or using the <code>gen</code> keyword.</p></div></div><h3><a class="nav-anchor" id="Keyword-arguments-may-be-functions-or-objects-1" href="#Keyword-arguments-may-be-functions-or-objects-1">Keyword arguments may be functions or objects</a></h3><p>Most keyword arguments may be either functions or static objects. For instance, in the above example, the action space is specified by a static list provided as the <code>actions</code> keyword argument. In other problems, the action space might be state-dependent and hence specified as a function of the state, for instance if the mountain car only had a braking action, the following code might be used:</p><pre><code class="language-julia">actions = function (s)
    v = s[2]
    if v &gt;= 0.0
        return [0., -1.]
    else
        return [0., 1.]
    end
end</code></pre><p>When the keyword argument is a function, it should take all of the arguments that the corresponding POMDPs.jl function takes, but <em>without the model argument</em>. For instance, the signature for <code>POMDPs.isterminal</code> is <code>isterminal(m::Union{POMDP, MDP}, s)</code>, so the <code>isterminal</code> keyword argument takes a function of only <code>s</code> (the <code>m</code> model argument is omitted) as shown in the example above.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>When the POMDPs.jl function has a variable number of arguments, it can be confusing to know which version to implement. For example POMDPs.jl has the methods</p><pre><code class="language-julia">reward(m, s, a)
reward(m, s, a, sp)
reward(m, s, a, sp, o)</code></pre><p>in the interface. Usually the best bet is to implement the one with the most arguments, i.e.</p><pre><code class="language-julia">reward = (s, a, sp, o) -&gt; s^2</code></pre><p>However, in general, a specific solver may require a specific number of arguments (keep an eye out for <code>MethodErrors</code> to know which version is needed). If multiple methods are needed, they can be defined outside of the Quick(PO)MDP constructor, e.g.</p><pre><code class="language-julia">myreward(s, a) = s^2
myreward(s, a, sp) = s^2
m = QuickMDP(
    ...
    reward = myreward,
    ...
)</code></pre></div></div><h2><a class="nav-anchor" id="IDs-and-defining-methods-1" href="#IDs-and-defining-methods-1">IDs and defining methods</a></h2><p>Each Quick(PO)MDP has a unique id, which is stored as a type parameter. By default this id is randomly generated, but it can also be specified as a positional argument.</p><p>This ID type parameter allows specialized methods to be defined for a specific Quick(PO)MDP. For example one could override <code>ordered_states</code> function from <code>POMDPModelTools</code> as follows:</p><pre><code class="language-julia">m = QuickMDP(...)

POMDPModelTools.ordered_states(m::typeof(m)) = 1:3</code></pre><p>or</p><pre><code class="language-julia">m = QuickMDP(:myproblem, ...)

POMDPModelTools.ordered_states(m::QuickMDP{:myproblem}) = 1:3</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>A manually-specified ID must be a suitable type parameter value such as a <code>Symbol</code> or other <code>isbits</code> type.</p></div></div><h2><a class="nav-anchor" id="State,-action,-and-observation-type-inference-1" href="#State,-action,-and-observation-type-inference-1">State, action, and observation type inference</a></h2><p>The state, action, and observation types for a Quick(PO)MDP are usually inferred from the keyword arguments. For instance, in the example above, the state type is inferred to be <code>Tuple{Float64, Float64}</code> from the <code>initialstate</code> argument, and the action type is inferred to be <code>Float64</code> from the <code>actions</code> argument. If QuickPOMDPs is unable to infer one of these types, or the user wants to override or specify the type manually, the <code>statetype</code>, <code>actiontype</code>, or <code>obstype</code> keywords should be used.</p><h2><a class="nav-anchor" id="Visualization-1" href="#Visualization-1">Visualization</a></h2><p>Visualization can be accomplished using the <code>render</code> keyword argument. See the <a href="https://juliapomdp.github.io/POMDPModelTools.jl/latest/visualization.html#POMDPModelTools.render">documentation of <code>POMDPModelTools.render</code></a> for more information. An example can be found in <a href="https://github.com/JuliaPOMDP/QuickPOMDPs.jl/blob/master/examples/lightdark.jl">example/mountaincar<em>with</em>visualization.jl</a>.</p><footer><hr/><a class="previous" href="../discrete_explicit/"><span class="direction">Previous</span><span class="title">Discrete Explicit Interface</span></a></footer></article></body></html>
